package q021_030.q022_括号生成.code;

import java.util.ArrayList;
import java.util.List;

/**
 *
 * DFS 解法
 * 既然题目是求所有的方案，那只能爆搜了，爆搜可以使用 DFS 来做。
 *
 * 从数据范围 1⩽n⩽8 来说，DFS 应该是稳稳的 AC。
 *
 * 这题的关键是要我们从题目中发掘一些性质：
 *  1、括号数为 n，那么一个合法的括号组合，应该包含 n 个左括号和 n 个右括号，组合总长度为 2n。
 *  2、一对合法的括号，应该是先出现左括号，再出现右括号。那么意味着*任意一个右括号的左边，至少有一个左括号。
 *
 * 其中性质 2 是比较难想到的。
 *
 * 我们可以用反证法来证明性质 2 总是成立：
 * 假设某个右括号不满足「其左边至少有一个左括号」，即其左边没有左括号，那么这个右括号就找不到一个与之对应的左括号进行匹配，这样的组合必然不是有效的括号组合。
 *
 * 使用我们 20. 有效的括号 的思路（栈）去验证的话，必然验证不通过。
 *
 * 掌握了这两个性质之后，我们可以设定一个初始值为 0 的得分值，令往组合添加一个 ( 得分值 +1，往组合添加一个 ) 得分值 -1。
 *
 * 当进行了这样的定义之后，不难发现：
 * 1、一个合法的括号组合，最终得分必然为 0 （左括号和右括号的数量相等，对应了性质 1）。
 * 2、整个 DFS 过程中，得分值范围在 [0, n]（得分不可能超过 n 意味着不可能添加数量超过 n 的左括号，对应了性质 1；得分不可能为负数，意味着每一个右括号必然有一个左括号进行匹配，对应性质 2）
 *
 *
 */
public class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList<>();
        dfs(0, n * 2, 0, n, "", ans);
        return ans;
    }

    /**
     * i: 当前遍历到位置
     * n: 字符总长度
     * score: 当前得分，令 '(' 为 1， ')' 为 -1
     * max: 最大得分值
     * path: 当前的拼接结果
     * ans: 最终结果集
     */
    void dfs(int i, int n, int score, int max, String path, List<String> ans) {
        if (i == n) {
            if (score == 0) {
                ans.add(path);
            }
        } else {
            // 如果添加左括号后不超过 max（有效值），则可以添加
            if (score + 1 <= max) {
                dfs(i + 1, n, score + 1, max, path + "(", ans);
            }
            // 如果添加右括号后不少于 0（有效值），则可以添加
            if (score - 1 >= 0) {
                dfs(i + 1, n, score - 1, max, path + ")", ans);
            }
        }
    }
}