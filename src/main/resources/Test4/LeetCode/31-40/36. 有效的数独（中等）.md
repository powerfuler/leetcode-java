### 题目描述

这是 LeetCode 上的 **[36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/solution/ha-xi-biao-jie-fa-shu-zu-jie-fa-by-ac_oi-feac/)** ，难度为 **中等**。

Tag : 「哈希表」、「数独问题」



请你判断一个 9x9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。

1. 数字 1-9 在每一行只能出现一次。
2. 数字 1-9 在每一列只能出现一次。
3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 '.' 表示。

注意：
* 一个有效的数独（部分已被填充）不一定是可解的。
* 只需要根据以上规则，验证已经填入的数字是否有效即可。


示例 1：
```
输入：board = 
[["5","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]

输出：true
```
示例 2：
```
输入：board = 
[["8","3",".",".","7",".",".",".","."]
,["6",".",".","1","9","5",".",".","."]
,[".","9","8",".",".",".",".","6","."]
,["8",".",".",".","6",".",".",".","3"]
,["4",".",".","8",".","3",".",".","1"]
,["7",".",".",".","2",".",".",".","6"]
,[".","6",".",".",".",".","2","8","."]
,[".",".",".","4","1","9",".",".","5"]
,[".",".",".",".","8",".",".","7","9"]]

输出：false

解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

提示：
* board.length == 9
* board[i].length == 9
* board[i][j] 是一位数字或者 '.'


---

### 哈希表解法

由于只要我们判断是否为有效的数独。

所以我们只需要对 `board` 中出现的数进行判断，如果 `board` 中有数违反了数独的规则，返回 `false`，否则返回 `true`。

直观上，我们很容易想到使用**哈希表**来记录某行/某列/某个小方块出现过哪些数字，来帮助我们判断是否符合「有效数独」的定义。

这道题唯一的难点可能是在于如何确定某个数落在哪个小方块中，我们可以去小方块进行编号：

![xx1.png](https://pic.leetcode-cn.com/1611905609-HXFmUe-xx1.png)

然后推导出小方块编号和行列的关系为： `idx = i / 3 * 3 + j / 3`。

代码：
```Java []
class Solution3 {
    public boolean isValidSudoku(char[][] board) {
        Map<Integer, Set<Integer>> row  = new HashMap<>(), col = new HashMap<>(), area = new HashMap<>();
        for (int i = 0; i < 9; i++) {
            row.put(i, new HashSet<>());
            col.put(i, new HashSet<>());
            area.put(i, new HashSet<>());
        }
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') continue;
                int c = board[i][j] - '1';
                int idx = i / 3 * 3 + j / 3;
                if (!row.get(i).contains(c) && !col.get(j).contains(c) && !area.get(idx).contains(c)) {
                    row.get(i).add(c);
                    col.get(j).add(c);
                    area.get(idx).add(c);
                } else {
                    return false;
                }
            }
        }
        return true;
    }
}
```

* 时间复杂度：在固定 `9*9` 的问题里，复杂度不随数据变化而变化。复杂度为 $O(1)$
* 空间复杂度：在固定 `9*9` 的问题里，复杂度不随数据变化而变化。复杂度为 $O(1)$

---

### 数组解法

大多数的哈希表计数问题，都能转换为使用数组解决。

虽然时间复杂度一样，但是哈希表的更新和查询复杂度是平均为 $O(1)$，而定长数组的的更新和查询复杂度是严格 $O(1)$。

因此从执行效率上来说，数组要比哈希表快上不少：

代码：
```Java []
class Solution3 {
    public boolean isValidSudoku(char[][] board) {
        boolean[][] row = new boolean[9][9], col = new boolean[9][9], area = new boolean[9][9];        
        for (int i = 0; i < 9; i++) {
            for (int j = 0; j < 9; j++) {
                if (board[i][j] == '.') continue;
                int c = board[i][j] - '1';
                int idx = i / 3 * 3 + j / 3;
                if (!row[i][c] && !col[j][c] && !area[idx][c]) {
                    row[i][c] = col[j][c] = area[idx][c] = true;
                } else {
                    return false;
                }
            }
        }
        return true;
    }
}
```
* 时间复杂度：在固定 `9*9` 的问题里，复杂度不随数据变化而变化。复杂度为 $O(1)$
* 空间复杂度：在固定 `9*9` 的问题里，复杂度不随数据变化而变化。复杂度为 $O(1)$

---

### 最后

这是我们「刷穿 LeetCode」系列文章的第 `No.36` 篇，系列开始于 2021/01/01，截止于起始日 LeetCode 上共有 1916 道题目，部分是有锁题，我们将先将所有不带锁的题目刷完。

在这个系列文章里面，除了讲解解题思路以外，还会尽可能给出最为简洁的代码。如果涉及通解还会相应的代码模板。

为了方便各位同学能够电脑上进行调试和提交代码，我建立了相关的仓库：https://github.com/SharingSource/LogicStack-LeetCode。

在仓库地址里，你可以看到系列文章的题解链接、系列文章的相应代码、LeetCode 原题链接和其他优选题解。

